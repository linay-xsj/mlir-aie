<!-- Autogenerated by mlir-tblgen; don't manually edit -->
# 'AIEX' Dialect

This is a dialect for experimental work related to AIEngine processors.
The expectation is that new ideas can be developed here before migration
to the more mature AIE dialect.


[TOC]

## Operation definition

### `AIEX.bp_dest` (::xilinx::AIEX::BPDestOp)

A destination port


Syntax:

```
operation ::= `AIEX.bp_dest` `<` $tile `,` $bundle `:` $channel `>` attr-dict
```

An object representing the destination of a  Broad Packet. This must exist
within an [AIE.bp_id] operation.
See [AIE.broadcast_packet] for an example.

Traits: HasParent<BPIDOp>

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `bundle` | xilinx::AIE::WireBundleAttr | Bundle of wires
| `channel` | ::mlir::IntegerAttr | 32-bit signless integer attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `tile` | index

### `AIEX.bp_id` (::xilinx::AIEX::BPIDOp)

A set of packets that share the same ID


Syntax:

```
operation ::= `AIEX.bp_id` `(` $ID `)` regions attr-dict
```

A set of destination packets that share the same source and ID. This must exist
within an [AIE.broadcast_packet] operation.
See [AIE.broadcast_packet]for an example.

Traits: SingleBlockImplicitTerminator<AIE::EndOp>

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `ID` | ::mlir::IntegerAttr | 8-bit signless integer attribute

### `AIEX.broadcast_packet` (::xilinx::AIEX::BroadcastPacketOp)

Combination of broadcast and packet-switch


Syntax:

```
operation ::= `AIEX.broadcast_packet` `(` $tile `,` $bundle `:` $channel `)` regions attr-dict
```

An abstraction of broadcast and packet-switched flow. During place and
route, it will be replaced by packet-switched flow and further replaced
by MasterSets and PacketRules inside switchboxes.

Example:
```
  %70 = AIE.tile(7, 0)
  %73 = AIE.tile(7, 3)
  %74 = AIE.tile(7, 4)
  %63 = AIE.tile(6, 3)
  %64 = AIE.tile(6, 4)
  AIE.broadcast_packet(%70, "DMA" : 0){
    AIE.bp_id(0x0){
      AIE.bp_dest<%73, "DMA" : 0>
      AIE.bp_dest<%63, "DMA" : 0>
    }
    AIE.bp_id(0x1){
      AIE.bp_dest<%74, "DMA" : 0>
      AIE.bp_dest<%64, "DMA" : 0>
    }
  }
```

Traits: SingleBlockImplicitTerminator<AIE::EndOp>

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `bundle` | xilinx::AIE::WireBundleAttr | Bundle of wires
| `channel` | ::mlir::IntegerAttr | 32-bit signless integer attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `tile` | index

### `AIEX.connection` (::xilinx::AIEX::ConnectionOp)

A logical circuit-switched connection between cores


Syntax:

```
operation ::= `AIEX.connection` `(` $source `,` $sourceBundle `:` $sourceChannel `,` $dest `,` $destBundle `:` $destChannel `)` attr-dict
```

The "aie.connection" operation represents a circuit switched connection between two endpoints, usually
"aie.core" operations.  During routing, this is replaced by "aie.connect" operations which represent
the programmed connections inside a switchbox, along with "aie.wire" operations which represent
physical connections between switchboxes and other components.  Note that while "aie.flow" operations
can express partial routes between tiles, this is not possible with "aie.connection" operations.

Example:
  %22 = aie.tile(2, 2)
  %c22 = aie.core(%22)
  %11 = aie.tile(1, 1)
  %c11 = aie.core(%11)
  aie.flow(%c22, "Core" : 0, %c11, "Core" : 1)


#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `sourceBundle` | xilinx::AIE::WireBundleAttr | Bundle of wires
| `sourceChannel` | ::mlir::IntegerAttr | 32-bit signless integer attribute
| `destBundle` | xilinx::AIE::WireBundleAttr | Bundle of wires
| `destChannel` | ::mlir::IntegerAttr | 32-bit signless integer attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `source` | index
| `dest` | index

### `AIEX.getTile` (::xilinx::AIEX::GetTileOp)

Get a reference to an AIE tile


Syntax:

```
operation ::= `AIEX.getTile` `(` $col `,` $row `)` attr-dict
```

Return a reference to an AIE tile, given the column and the row of the tile.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `col` | index
| `row` | index

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | index

### `AIEX.herd` (::xilinx::AIEX::HerdOp)

Declare a herd which is a bundle of core organized in a rectangular shape


Syntax:

```
operation ::= `AIEX.herd` `[` $width `]` `[` $height `]` attr-dict
```

This operation creates a group of AIE tiles in 2D shape.

Example:
  %herd0 = AIE.herd[1][1] // a single AIE tile. location unknown
  %herd1 = AIE.herd[4][1] // a row of four-AIE tile

The operation can be used in replacement of a TileOp -- in case we want to select a group of
hardware entities (cores, mems, switchboxes) instead of individual entity, and we don't want to
specify their locations just yet. This can be useful if we want to generate parameterizable
code (the column and row values are parameterized).

Example:

  %herd = AIE.herd[2][2] // a herd of 2x2 AIE tiles

  AIE.core(%herd) {
    // all the cores belong to this herd runs the same code
  }

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `width` | ::mlir::IntegerAttr | 32-bit signless integer attribute
| `height` | ::mlir::IntegerAttr | 32-bit signless integer attribute

#### Results:

| Result | Description |
| :----: | ----------- |
&laquo;unnamed&raquo; | index

### `AIEX.iter` (::xilinx::AIEX::IterOp)

An iter operation


Syntax:

```
operation ::= `AIEX.iter` `(` $start `,` $end `,` $stride `)` attr-dict
```

This operation generates index values that can be used with the SelectOp to select a group of tiles
from a herd.

Example:
  %iter0 = AIE.iter(0, 15, 1) // 0, 1, 2, ... , 15
  %iter1 = AIE.iter(2, 8, 2)  // 2, 4, 6

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `start` | ::mlir::IntegerAttr | 32-bit signless integer attribute
| `end` | ::mlir::IntegerAttr | 32-bit signless integer attribute
| `stride` | ::mlir::IntegerAttr | 32-bit signless integer attribute

#### Results:

| Result | Description |
| :----: | ----------- |
&laquo;unnamed&raquo; | index

### `AIEX.memcpy` (::xilinx::AIEX::MemcpyOp)

A memcpy op


Syntax:

```
operation ::= `AIEX.memcpy` $tokenName `(` $acqValue `,` $relValue `)` `(`
              $srcTile `:` `<` $srcBuf `,` $srcOffset `,` $srcLen `>` `,`
              $dstTile `:` `<` $dstBuf `,` $dstOffset `,` $dstLen `>` `)`
              attr-dict `:` `(` type($srcBuf) `,` type($dstBuf) `)`
```

This operation defines a logical data transfer of a buffer from a source tile to another buffer
from a destination tile.

This operation should be lowered to Mem ops with DMA setup and Flow ops for routing data from
the source tile to the dest. tile.

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `tokenName` | ::mlir::FlatSymbolRefAttr | flat symbol reference attribute
| `acqValue` | ::mlir::IntegerAttr | 32-bit signless integer attribute
| `relValue` | ::mlir::IntegerAttr | 32-bit signless integer attribute
| `srcOffset` | ::mlir::IntegerAttr | 32-bit signless integer attribute
| `srcLen` | ::mlir::IntegerAttr | 32-bit signless integer attribute
| `dstOffset` | ::mlir::IntegerAttr | 32-bit signless integer attribute
| `dstLen` | ::mlir::IntegerAttr | 32-bit signless integer attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `srcTile` | index
| `srcBuf` | memref of any type values
| `dstTile` | index
| `dstBuf` | memref of any type values

### `AIEX.multi_dest` (::xilinx::AIEX::MultiDestOp)

A destination port of multicast flow


Syntax:

```
operation ::= `AIEX.multi_dest` `<` $tile `,` $bundle `:` $channel `>` attr-dict
```

An object representing the destination of a multicast flow. This must exist
within an [AIEX.multicast] operation. There can be multiple destinations within an
AIEX.multicast Op.

See [AIEX.multicast]for an example.

Traits: HasParent<MulticastOp>

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `bundle` | xilinx::AIE::WireBundleAttr | Bundle of wires
| `channel` | ::mlir::IntegerAttr | 32-bit signless integer attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `tile` | index

### `AIEX.multicast` (::xilinx::AIEX::MulticastOp)

An abstraction of multicast


Syntax:

```
operation ::= `AIEX.multicast` `(` $tile `,` $bundle `:` $channel `)` regions attr-dict
```

An abstraction of broadcast. During place and
route, it will be replaced by multiple flows.

Example:
```
  %70 = AIE.tile(7, 0)
  %73 = AIE.tile(7, 3)
  %74 = AIE.tile(7, 4)
  %63 = AIE.tile(6, 3)
  %64 = AIE.tile(6, 4)
  AIEX.multicast(%70, "DMA" : 0){
    AIEX.multi_dest<%73, "DMA" : 0>
    AIEX.multi_dest<%74, "DMA" : 0>
    AIEX.multi_dest<%63, "DMA" : 0>
    AIEX.multi_dest<%64, "DMA" : 0>
  }
```

Traits: SingleBlockImplicitTerminator<AIE::EndOp>

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `bundle` | xilinx::AIE::WireBundleAttr | Bundle of wires
| `channel` | ::mlir::IntegerAttr | 32-bit signless integer attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `tile` | index

### `AIEX.place` (::xilinx::AIEX::PlaceOp)

A place operation that specifies the relative placement (XY) of one herd to another


Syntax:

```
operation ::= `AIEX.place` `(` $sourceHerd `,` $destHerd `,` $distX `,` $distY `)` attr-dict
```

A place operation that specifies the relative placement (XY) of one herd to another.

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `distX` | ::mlir::IntegerAttr | 32-bit signless integer attribute
| `distY` | ::mlir::IntegerAttr | 32-bit signless integer attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `sourceHerd` | index
| `destHerd` | index

### `AIEX.route` (::xilinx::AIEX::RouteOp)

A route operation that routes one herd to another


Syntax:

```
operation ::= `AIEX.route` `(` `<` $sourceHerds `,` $sourceBundle `:` $sourceChannel `>` `,`
              `<` $destHerds   `,` $destBundle   `:` $destChannel   `>` `)` attr-dict
```

A route operation that routes one herd to another.

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `sourceBundle` | xilinx::AIE::WireBundleAttr | Bundle of wires
| `sourceChannel` | ::mlir::IntegerAttr | 32-bit signless integer attribute
| `destBundle` | xilinx::AIE::WireBundleAttr | Bundle of wires
| `destChannel` | ::mlir::IntegerAttr | 32-bit signless integer attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `sourceHerds` | index
| `destHerds` | index

### `AIEX.select` (::xilinx::AIEX::SelectOp)

A select operation


Syntax:

```
operation ::= `AIEX.select` `(` $startHerd `,` $iterX `,` $iterY `)` attr-dict
```

This operation selects a group of tiles based on the selected indices.

Example:

  %herd = AIE.herd[4][4] // a herd of 4x4 tiles

  %ix = AIE.iter(0, 4, 1) // 0, 1, 2, 3
  %iy = AIE.iter(0, 1, 1) // 0

  %sub_herd = AIE.select(%herd, %ix, %iy)

The SelectOp in the above example will select the tiles %herd[0][0], %herd[1][0],
%herd[2][0], %herd[3][0] (the first column of the herd).

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `startHerd` | index
| `iterX` | index
| `iterY` | index

#### Results:

| Result | Description |
| :----: | ----------- |
&laquo;unnamed&raquo; | index

### `AIEX.token` (::xilinx::AIEX::TokenOp)

Declare a token (a logical lock)


Syntax:

```
operation ::= `AIEX.token` `(` $value `)` attr-dict
```

This operation creates a logical lock. We use Symbol so that it can be referenced globally.
Unlike phsical locks, logical locks are unlimited, and we can specify any integer value
associated with a lock. The logical lock is used to manually specify the dependence of tasks, or
core executions.

The operation can also be generated automatically if the Dependence Analysis can be leveraged.

Example:
  AIE.token(0) {sym_name = "token0"} // Declare token0 with initial value of 0

  ...

  AIE.useToken @token0("Acquire", 0) // acquire token0 if its value is 0

  ...

  AIE.useToken @token0("Release", 5) // release token0 and set its value to 5


Interfaces: Symbol

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `value` | ::mlir::IntegerAttr | 32-bit signless integer attribute

### `AIEX.useToken` (::xilinx::AIEX::UseTokenOp)

acquire/release a logical lock


Syntax:

```
operation ::= `AIEX.useToken` $tokenName `(` $action `,` $value `)` attr-dict
```

This operation uses token (logical lock). A logical lock can be acquired or released with a value.
Similar to UseLockOp, this operation can be understood as "blocking" op.

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `tokenName` | ::mlir::FlatSymbolRefAttr | flat symbol reference attribute
| `value` | ::mlir::IntegerAttr | 32-bit signless integer attribute
| `action` | xilinx::AIE::LockActionAttr | lock acquire/release

